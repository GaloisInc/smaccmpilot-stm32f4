#/usr/bin/env python
'''
parse a MAVLink protocol XML file and generate a C implementation

Copyright Andrew Tridgell 2011
Copyright Pat Hickey 2013
Released under GNU GPL version 3 or later
'''

import sys, textwrap, os, time
import mavparse, mavtemplate

t = mavtemplate.MAVTemplate()

def message_imports(ms):
    imports = [ "import qualified SMACCMPilot.Mavlink.Messages."
              + m.name_module for m in ms ]
    return ("\n").join(imports)

def generate_messages_hs(directory, ms):
    '''generate umbrella haskell SMACCMPilot.Mavlink.Messages module'''
    exports = [ "module SMACCMPilot.Mavlink.Messages."
              + m.name_module for m in ms ]
    modules = ( "mavlinkMessageModules :: [Module]\n"
              + "mavlinkMessageModules =\n  [ "
              + ("\n  , ").join([ "SMACCMPilot.Mavlink.Messages.%s.%sModule" %
                  (m.name_module , m.name_camel) for m in ms])
              + "\n  ]\n"
              )
    messageLCs = ( "-- [(Message Id, (Message Length, Message CRC))]\n"
                 + "messageLensCRCs :: [(Word8, (Word8, Word8))]\n"
                 + "messageLensCRCs =\n"
                 + "  [ " + ("\n  , ").join(["(%3d, (%3d, %3d)) -- 0x%0.2X %s"
                                            % (m.id, m.wire_length, m.crc_extra,
                                                m.id, m.name)
                                            for m in ms])
                 + "\n  ]\n"
                 )

    f = open(os.path.join(directory, 'Messages.hs'), mode='w')
    t.write(f, '''
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE Rank2Types #-}

{- Module automatically generated by smavgen_ivory.py -}

module SMACCMPilot.Mavlink.Messages
  ( mavlinkMessageModules
  , messageLensCRCs
  ) where

import Data.Word (Word8)
import Ivory.Language

${imports}

${modulesList}

${messageLCs}

''', { 'exports': ("\n  , ").join(exports)
     , 'imports': message_imports(ms)
     , 'modulesList': modules
     , 'messageLCs': messageLCs
     })
    f.close()

def ivory_name(field , m):
    f = field.name.encode('ascii')
    # catch haskell reserved words
    if (f == "type" and m.name == "HEARTBEAT"):
        return "mavtype"
    if (f in ["type", "seq"]):
       return m.name.lower() + "_" + f
    else:
      return f

ivory_type = {
        'float'    : 'IFloat',
        'double'   : 'IDouble',
        'char'     : 'Uint8',
        'int8_t'   : 'Sint8',
        'uint8_t'  : 'Uint8',
        'uint8_t_mavlink_version' : 'Uint8',
        'int16_t'  : 'Sint16',
        'uint16_t' : 'Uint16',
        'int32_t'  : 'Sint32',
        'uint32_t' : 'Uint32',
        'int64_t'  : 'Sint64',
        'uint64_t' : 'Uint64'}
sizeof_type = {
        'float'    : 4,
        'double'   : 8,
        'char'     : 1,
        'int8_t'   : 1,
        'uint8_t'  : 1,
        'uint8_t_mavlink_version'  : 1,
        'int16_t'  : 2,
        'uint16_t' : 2,
        'int32_t'  : 4,
        'uint32_t' : 4,
        'int64_t'  : 8,
        'uint64_t' : 8,
        }


def generate_message_ivory(directory, m):
    '''generate haskell file containing ivory module'''
    scalar_defs = [ ivory_name(s,m) + " :: Stored " + ivory_type[s.type]
                    for s in m.scalar_fields ]
    array_defs = [ ivory_name(s,m) + " :: Array %d (Stored %s)" %
                    (s.array_length, ivory_type[s.type])
                    for s in m.array_fields ]
    scalar_pack_calls = [ "call_ pack buf %d =<< deref (msg ~> %s)" %
                    (s.wire_offset, ivory_name(s,m))
                    for s in m.scalar_fields]
    array_pack_calls = [ "arrayPack buf %d (msg ~> %s)" %
                    (s.wire_offset, ivory_name(s,m))
                    for s in m.array_fields]
    scalar_unpack_calls = [ "store (msg ~> %s) =<< call unpack buf %d" %
                            (ivory_name(s, m), s.wire_offset)
                            for s in m.scalar_fields]
    array_unpack_calls = [ "arrayUnpack buf %d (msg ~> %s)" %
                           (s.wire_offset, ivory_name(s, m))
                           for s in m.array_fields]
    mdict = m.__dict__
    mdict.update({'struct_fields': ("\n  ; ").join(scalar_defs + array_defs)
                 ,'packing': ("\n  ").join(scalar_pack_calls + array_pack_calls)
                 ,'unpacking': "\n  ".join(scalar_unpack_calls + array_unpack_calls)})
    f = open(os.path.join(directory, 'Messages/%s.hs' % m.name_module), mode='w')
    t.write(f, '''
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE MultiParamTypeClasses #-}

-- Autogenerated Mavlink v1.0 implementation: see smavgen_ivory.py

module SMACCMPilot.Mavlink.Messages.${name_module} where

import SMACCMPilot.Mavlink.Pack
import SMACCMPilot.Mavlink.Unpack
import SMACCMPilot.Mavlink.Send
import qualified SMACCMPilot.Communications as Comm

import Ivory.Language
import Ivory.Stdlib

${name_camel}MsgId :: Uint8
${name_camel}MsgId = ${id}

${name_camel}CrcExtra :: Uint8
${name_camel}CrcExtra = ${crc_extra}

${name_camel}Module :: Module
${name_camel}Module = package "mavlink_${name_lower}_msg" $ do
  depend packModule
  depend mavlinkSendModule
  incl mk${name_module}Sender
  incl ${name_camel}Unpack
  defStruct (Proxy :: Proxy "${name_lower}_msg")

[ivory|
struct ${name_lower}_msg
  { ${struct_fields}
  }
|]

mk${name_module}Sender ::
  Def ('[ ConstRef s0 (Struct "${name_lower}_msg")
        , Ref s1 (Stored Uint8) -- seqNum
        , Ref s1 Comm.MAVLinkArray -- tx buffer
        ] :-> ())
mk${name_module}Sender =
  proc "mavlink_${name_lower}_msg_send"
  $ \msg seqNum sendArr -> body
  $ do
  arr <- local (iarray [] :: Init (Array ${wire_length} (Stored Uint8)))
  let buf = toCArray arr
  ${packing}
  -- 6: header len, 2: CRC len
  let usedLen = 6 + ${wire_length} + 2 :: Integer
  let sendArrLen = arrayLen sendArr
  if sendArrLen < usedLen
    then error "${name_camel} payload of length ${wire_length} is too large!"
    else do -- Copy, leaving room for the payload
            arrCopy sendArr arr 6
            call_ mavlinkSendWithWriter
                    ${name_camel}MsgId
                    ${name_camel}CrcExtra
                    ${wire_length}
                    seqNum
                    sendArr
            let usedLenIx = fromInteger usedLen
            -- Zero out the unused portion of the array.
            for (fromInteger sendArrLen - usedLenIx) $ \ix ->
              store (sendArr ! (ix + usedLenIx)) 0
            retVoid

instance MavlinkUnpackableMsg "${name_lower}_msg" where
    unpackMsg = ( ${name_camel}Unpack , ${name_camel}MsgId )

${name_camel}Unpack :: Def ('[ Ref s1 (Struct "${name_lower}_msg")
                             , ConstRef s2 (CArray (Stored Uint8))
                             ] :-> () )
${name_camel}Unpack = proc "mavlink_${name_lower}_unpack" $ \ msg buf -> body $ do
  ${unpacking}

''', mdict)
    f.close()

class mav_include(object):
    def __init__(self, base):
        self.base = base

def process_xml_wtf(basename, xml):
    '''generate headers for one XML file'''

    directory = basename

    if xml.little_endian:
        xml.mavlink_endian = "MAVLINK_LITTLE_ENDIAN"
    else:
        xml.mavlink_endian = "MAVLINK_BIG_ENDIAN"

    if xml.crc_extra:
        xml.crc_extra_define = "1"
    else:
        xml.crc_extra_define = "0"

    if xml.sort_fields:
        xml.aligned_fields_define = "1"
    else:
        xml.aligned_fields_define = "0"

    # work out the included headers
    xml.include_list = []
    for i in xml.include:
        base = i[:-4]
        xml.include_list.append(mav_include(base))

    # form message lengths array
    xml.message_lengths_array = ''
    for mlen in xml.message_lengths:
        xml.message_lengths_array += '%u, ' % mlen
    xml.message_lengths_array = xml.message_lengths_array[:-2]

    # and message CRCs array
    xml.message_crcs_array = ''
    for crc in xml.message_crcs:
        xml.message_crcs_array += '%u, ' % crc
    xml.message_crcs_array = xml.message_crcs_array[:-2]

    # form message info array
    xml.message_info_array = ''
    for name in xml.message_names:
        if name is not None:
            xml.message_info_array += 'MAVLINK_MESSAGE_INFO_%s, ' % name
        else:
            # Several C compilers don't accept {NULL} for
            # multi-dimensional arrays and structs
            # feed the compiler a "filled" empty message
            xml.message_info_array += '{"EMPTY",0,{{"","",MAVLINK_TYPE_CHAR,0,0,0}}}, '
    xml.message_info_array = xml.message_info_array[:-2]

    # add some extra field attributes for convenience with arrays
    for m in xml.message:
        m.msg_name = m.name
        if xml.crc_extra:
            m.crc_extra_arg = ", %s" % m.crc_extra
        else:
            m.crc_extra_arg = ""
        for f in m.fields:
            if f.print_format is None:
                f.c_print_format = 'NULL'
            else:
                f.c_print_format = '"%s"' % f.print_format
            if f.array_length != 0:
                f.array_suffix = '[%u]' % f.array_length
                f.array_prefix = '*'
                f.array_tag = '_array'
                f.array_arg = ', %u' % f.array_length
                f.array_return_arg = '%s, %u, ' % (f.name, f.array_length)
                f.array_const = 'const '
                f.decode_left = ''
                f.decode_right = ', %s->%s' % (m.name_lower, f.name)
                f.return_type = 'uint16_t'
                f.get_arg = ', %s *%s' % (f.type, f.name)
                if f.type == 'char':
                    f.c_test_value = '"%s"' % f.test_value
                else:
                    test_strings = []
                    for v in f.test_value:           test_strings.append(str(v))
                    f.c_test_value = '{ %s }' % ', '.join(test_strings)
            else:
                f.array_suffix = ''
                f.array_prefix = ''
                f.array_tag = ''
                f.array_arg = ''
                f.array_return_arg = ''
                f.array_const = ''
                f.decode_left = "%s->%s = " % (m.name_lower, f.name)
                f.decode_right = ''
                f.get_arg = ''
                f.return_type = f.type
                if f.type == 'char':
                    f.c_test_value = "'%s'" % f.test_value
                elif f.type == 'uint64_t':
                    f.c_test_value = "%sULL" % f.test_value                    
                elif f.type == 'int64_t':
                    f.c_test_value = "%sLL" % f.test_value                    
                else:
                    f.c_test_value = f.test_value

def process_xml(basename, xml):
    # cope with uint8_t_mavlink_version
    for m in xml.message:
        m.arg_fields = []
        m.array_fields = []
        m.scalar_fields = []
        for f in m.ordered_fields:
            if f.array_length != 0:
                m.array_fields.append(f)
            else:
                m.scalar_fields.append(f)
        for f in m.fields:
            if not f.omit_arg:
                m.arg_fields.append(f)
                f.putname = f.name
            else:
                f.putname = f.const_value
    return xml

def generate_messages(basename, xml_list):
    messages = []
    print("Generating SMACCMPilot.Mavlink.Messages modules in directory %s" %
          basename)
    mavparse.mkdir_p(basename)

    for xml in xml_list:
        process_xml(basename, xml);
        for m in xml.message:
            generate_message_ivory(basename, m)
            messages.append(m)

    generate_messages_hs(basename, messages)

