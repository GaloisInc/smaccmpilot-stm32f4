
module SMACCMPilot.Flight.Law.TestApp where

import Ivory.Tower

import SMACCMPilot.Flight.Platform
import SMACCMPilot.Flight.Datalink
import SMACCMPilot.Flight.IO
import SMACCMPilot.Flight.Law

import           SMACCMPilot.Comm.Tower.Attr
import           SMACCMPilot.Comm.Tower.Interface.ControllableVehicle

app :: (e -> FlightPlatform)
    -> Tower e ()
app tofp = do

  (attrs, _streams) <- datalinkTower tofp 115200

  -- Don't hook anything up to outputs!
  (_, output_cl) <- channel
  (_, output_motors) <- channel

  -- Inputs generated by flightIOTower will be forwarded:
  rcinput_ui <- channel
  rcinput_cm <- channel
  rcinput_am <- channel

  flightIOTower tofp attrs
    (fst rcinput_ui)
    (fst rcinput_cm)
    (fst rcinput_am)
    output_cl
    output_motors

  -- No sensors for the unit test:
  gyro_cal_output <- channel
  accel_cal_output <- channel
  mag_cal_output <- channel
  sensors_output <- channel

  let lawInputs = LawInputs
        { lawinput_rcinput_arming   = snd rcinput_am
        , lawinput_rcinput_ui       = snd rcinput_ui
        , lawinput_rcinput_modes    = snd rcinput_cm
        , lawinput_telem_arming     = attrReaderChan (armingRequest attrs)
        , lawinput_telem_ui         = attrReaderChan (userInputRequest attrs)
        , lawinput_telem_modes      = attrReaderChan (controlModesRequest attrs)
        , lawinput_px4io_state      = attrReaderChan (px4ioState attrs)
        , lawinput_gyro_cal_output  = snd gyro_cal_output
        , lawinput_accel_cal_output = snd accel_cal_output
        , lawinput_mag_cal_output   = snd mag_cal_output
        , lawinput_sensors_output   = snd sensors_output
        }


  control_law <- channel
  user_input_result <- channel
  lawTower lawInputs (fst control_law) (fst user_input_result)

  attrProxy (controlLaw attrs) (snd control_law)
  attrProxy (userInput attrs) (snd user_input_result)

