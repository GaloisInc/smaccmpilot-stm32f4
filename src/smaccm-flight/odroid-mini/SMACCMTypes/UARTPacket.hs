{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}

{-# OPTIONS_GHC -fno-warn-orphans #-}
-- | This module contains definitions that correspond to the UART
-- packet type generated by the AADL model. Ideally, we would consume
-- the output of these tools directly, but keeping these in sync and
-- providing conversions to the types we use internally works.
module SMACCMTypes.UARTPacket (to_smaccm, from_smaccm) where

import Ivory.Language

import Ivory.Tower

import Tower.Odroid.UART

{-
typedef uint8_t SMACCM_DATA__UART_Buffer [255];

typedef
      struct SMACCM_DATA__UART_Packet_i {
         SMACCM_DATA__UART_Buffer buf  ;
         int32_t buf_len  ;
      } SMACCM_DATA__UART_Packet_i ;
-}

smaccm_UART_module :: Module
smaccm_UART_module = package "smaccm_UART_module" $ do
  dependByName "tb_smaccmcopter_types"

[ivory|
struct SMACCM_DATA__UART_Packet_i
  { buf :: Array 255 (Stored Uint8)
  ; buf_len :: Sint32
  }
|]

from_smaccm ::
     ChanOutput ('Struct "SMACCM_DATA__UART_Packet_i")
  -> Tower eff (ChanOutput UartPacket)
from_smaccm smaccm_in = do
  towerDepends smaccm_UART_module
  towerModule  smaccm_UART_module
  towerDepends uartModule
  towerModule  uartModule
  uart_packet_out <- channel
  monitor "from_smaccm_uart" $ do
    handler smaccm_in "from_smaccm_uart" $ do
      e <- emitter (fst uart_packet_out) 1
      callback $ \smaccm -> do
        smaccm_buf_len <- deref (smaccm ~> buf_len)
        uart_packet <- local $ istruct [
            stringLengthL .= (ival smaccm_buf_len)
          ]
        refCopy (uart_packet ~> stringDataL) (smaccm ~> buf)
        emit e (constRef uart_packet)
  return (snd uart_packet_out)

to_smaccm ::
     ChanInput ('Struct "SMACCM_DATA__UART_Packet_i")
  -> Tower eff (ChanInput UartPacket)
to_smaccm smaccm_out = do
  towerDepends smaccm_UART_module
  towerModule  smaccm_UART_module
  towerDepends uartModule
  towerModule  uartModule
  uart_packet_out <- channel
  monitor "to_smaccm_uart" $ do
    handler (snd uart_packet_out) "to_smaccm_uart" $ do
      e <- emitter smaccm_out 1
      callback $ \uart_packet -> do
        packet_buf_len <- deref (uart_packet ~> stringLengthL)
        smaccm <- local $ istruct [
            buf_len .= (ival packet_buf_len)
          ]
        refCopy (smaccm ~> buf) (uart_packet ~> stringDataL)
        emit e (constRef smaccm)
  return (fst uart_packet_out)
