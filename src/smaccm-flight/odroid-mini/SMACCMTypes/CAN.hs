{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}

{-# OPTIONS_GHC -fno-warn-orphans #-}
-- | This module contains definitions that correspond to the CAN frame
-- type generated by the AADL model. Ideally, we would consume the
-- output of these tools directly, but keeping these in sync and
-- providing conversions to the types we use internally works.
module SMACCMTypes.CAN (to_smaccm, from_smaccm) where

import Ivory.Language

import Ivory.Tower

import Ivory.Tower.HAL.Bus.CAN

import Prelude hiding (id)

{-
typedef uint8_t SMACCM_DATA__CAN_Buffer [8];

typedef
      struct SMACCM_DATA__CAN_Frame_i {
         uint32_t id  ;
         SMACCM_DATA__CAN_Buffer buf  ;
         uint8_t buf_len  ;
      } SMACCM_DATA__CAN_Frame_i ;
-}

smaccm_can_module :: Module
smaccm_can_module = package "smaccm_can_module" $ do
  dependByName "tb_CAN_Framing"

[ivory|
struct SMACCM_DATA__CAN_Frame_i
  { id      :: Uint32
  ; buf     :: Array 8 (Stored Uint8)
  ; buf_len :: Uint8
  }
|]

from_smaccm ::
     ChanOutput ('Struct "SMACCM_DATA__CAN_Frame_i")
  -> Tower eff (ChanOutput ('Struct "can_message"))
from_smaccm smaccm_in = do
  towerDepends smaccm_can_module
  towerModule  smaccm_can_module
  can_message_out <- channel
  monitor "from_smaccm_can" $ do
    handler smaccm_in "from_smaccm_can" $ do
      e <- emitter (fst can_message_out) 1
      callback $ \smaccm -> do
        smaccm_id      <- deref (smaccm ~> id)
        smaccm_buf_len <- deref (smaccm ~> buf_len)
        msg <- local $ istruct [
            can_message_id  .= (ival (fromRep smaccm_id))
          , can_message_len .= (ival (toIx smaccm_buf_len))
          ]
        refCopy (msg ~> can_message_buf) (smaccm ~> buf)
        emit e (constRef msg)
  return (snd can_message_out)

to_smaccm ::
     ChanInput ('Struct "SMACCM_DATA__CAN_Frame_i")
  -> Tower eff (ChanInput ('Struct "can_message"))
to_smaccm smaccm_out = do
  towerDepends smaccm_can_module
  towerModule  smaccm_can_module
  can_message_out <- channel
  monitor "to_smaccm_can" $ do
    handler (snd can_message_out) "to_smaccm_can" $ do
      e <- emitter smaccm_out 1
      callback $ \msg -> do
        msg_id      <- deref (msg ~> can_message_id)
        msg_buf_len <- deref (msg ~> can_message_len)
        smaccm <- local $ istruct [
            id      .= (ival (toRep msg_id))
            -- Runtime cast should be safe here because we're
            -- converting from Ix 9, which will always fit in a uint8
          , buf_len .= (ival (castDefault (fromIx msg_buf_len)))
          ]
        refCopy (smaccm ~> buf) (msg ~> can_message_buf)
        emit e (constRef smaccm)
  return (fst can_message_out)
